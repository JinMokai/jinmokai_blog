---
title: "Astro5.0å®éªŒæ€§åŠŸèƒ½responsive-images"
pubDate: "2024-12-7"
updateDate: ""
description: "Astro5.0å®éªŒæ€§åŠŸèƒ½responsive-images,2024å¹´12æœˆ3å·ï¼Œastro5.0æ­£å¼å‘å¸ƒäº†!ä½œä¸ºAstroçˆ±å¥½è€…ï¼Œæœ‰ä¸€ä¸ªæ–°åŠŸèƒ½è®©æˆ‘å¾ˆå–œçˆ±ï¼Œè™½ç„¶è¿™æ˜¯å®éªŒæ€§åŠŸèƒ½ä½†æ˜¯å¯¹äºæˆ‘æ¥è¯´è¿™æ˜¯ä¸€ä¸ªéå¸¸å€¼å¾—å…´å¥‹çš„äº‹ï¼é‚£å°±æ˜¯responsive imagesï¼"
author: "ch_kai"
image:
  url: ""
  alt: ""
tags: ["astro"]
draft: false
---
import { Picture } from "astro:assets";
import ImageTip from "@src/components/ui/ImageTip.astro";

import image01 from "@src/assets/blogs/Astro5-responsive-images/image.png";
import image02 from "@src/assets/blogs/Astro5-responsive-images/image2.png";
import image03 from "@src/assets/blogs/Astro5-responsive-images/image3.png";
import image04 from "@src/assets/blogs/Astro5-responsive-images/image4.png";
import image05 from "@src/assets/blogs/Astro5-responsive-images/image5.png";
import image06 from "@src/assets/blogs/Astro5-responsive-images/image6.png";

# èƒŒæ™¯å†å²

åœ¨ Astro 5.0 ç‰ˆæœ¬ä¹‹å‰ï¼ŒAstro å›¢é˜Ÿåœ¨å›¾åƒä¼˜åŒ–æ–¹é¢åšäº†å¤§é‡å·¥ä½œã€‚ä¾‹å¦‚ï¼Œä»–ä»¬åœ¨å†…ç½®çš„å›¾åƒç»„ä»¶ä¸­æ·»åŠ äº†è®¸å¤šåŠŸèƒ½ï¼Œä»¥æ”¹å–„ç´¯ç§¯å¸ƒå±€åç§»ï¼ˆCLSï¼‰å’Œæœ€å¤§å†…å®¹ç»˜åˆ¶ï¼ˆLCPï¼‰ã€‚é€šè¿‡å¼•å…¥ decoding å’Œ densities å±æ€§ï¼Œå®ç°äº†å“åº”å¼å›¾åƒåŠ è½½æ•ˆæœï¼Œå¹¶é€šè¿‡ format å±æ€§æ”¯æŒå¤šç§å›¾åƒæ ¼å¼æ¸²æŸ“ã€‚æ­¤å¤–ï¼Œquality å±æ€§ä¹Ÿè¢«æ·»åŠ ï¼Œä»¥è°ƒæ•´å›¾åƒçš„åŠ è½½ä¼˜å…ˆçº§ã€‚

Astro 3.x ç‰ˆæœ¬å¼•å…¥çš„ picture ç»„ä»¶ï¼Œè¿›ä¸€æ­¥å¢å¼ºäº†å¯¹å¤šç§æ ¼å¼å›¾åƒåŠ è½½çš„å…¼å®¹æ€§ã€‚å°½ç®¡å¦‚æ­¤ï¼ŒAstro å›¢é˜Ÿåœ¨å›¾åƒå¤„ç†æ–¹é¢åšäº†å¾ˆå¤šæ”¹è¿›ï¼Œä½†åœ¨é«˜å±å¹•å¯†åº¦è®¾å¤‡ä¸Šè‡ªåŠ¨åŠ è½½é«˜åˆ†è¾¨ç‡å›¾åƒé€šå¸¸æ˜¯ä¸åˆç†çš„ã€‚å°¤å…¶æ˜¯åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œé«˜å¯†åº¦å±å¹•å¯èƒ½å¯¼è‡´ä¸å¿…è¦çš„é«˜åˆ†è¾¨ç‡å›¾åƒä¸‹è½½ï¼Œä»è€Œæ¶ˆè€—æ›´å¤šçš„ç½‘ç»œæµé‡ã€‚

> è¯¥åŠŸèƒ½æœ€æ—©ç‰ˆæœ¬å‘å¸ƒäº2024å¹´11æœˆ21å·ï¼ŒåŒ…ç‰ˆæœ¬ä¸º[astro@5.0.0-beta.9](https://github.com/withastro/astro/releases/tag/astro%405.0.0-beta.9)

# åŸºæœ¬åŠŸèƒ½

> ä»¥ä¸‹æ“ä½œéƒ½æ˜¯ç”Ÿäº§å¼€æ¨¡å¼ï¼Œå›¾ç‰‡è·¯å¾„ä¼šå¼€å‘ä¸ä¸€æ ·

æœ€åˆçš„\<Image>å’Œ\<picture>ç»„ä»¶åŠ è½½ä¿¡æ¯éƒ½æ˜¯è¿™æ ·çš„ï¼ˆæœªä½¿ç”¨densitieså±æ€§ï¼‰ï¼š


<ImageTip>
  <Picture
    src={image01}
    alt={"Image components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>


<ImageTip>
  <Picture
    src={image02}
    alt={"picture components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>

é€šè¿‡æœ€æ–°çš„[Astro5å®˜ç½‘æ–‡æ¡£](https://docs.astro.build/en/reference/experimental-flags/responsive-images/)å¯ä»¥çœ‹åˆ°é…ç½®ä¿¡æ¯ï¼Œæ·»åŠ å®éªŒæ€§åŠŸèƒ½åœ¨é…ç½®æ–‡ä»¶ä¸­

```mjs
{
  image: {
    experimentalLayout: 'responsive'
  },
  experimental: {
    responsiveImages: true,
  },
}
```

ç„¶åçœ‹åˆ°çš„Imageç»„ä»¶å’ŒPictureç»„ä»¶æ•ˆæœå°±æ˜¯ï¼š

<ImageTip>
  <Picture
    src={image03}
    alt={"Image components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>


<ImageTip>
  <Picture
    src={image04}
    alt={"picture components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>

æ³¨æ„è¿™é‡Œçš„sizeså±æ€§çš„min-width: 994pxï¼Œè¿™ä¸ª994pxçš„å€¼æ˜¯å›¾ç‰‡åŸå§‹å®½åº¦ï¼Œè¯¥å€¼ä¹Ÿä¼šåœ¨srcsetå±æ€§é‡Œé¢çš„æ§åˆ¶æœ€å¤§å€¼ï¼Œä¸‹é¢æœ‰ä¸€ä¸ª4096pxçš„å›¾ç‰‡ï¼Œæ¸²æŸ“è¾“å‡ºç»“æœå°†ä¼šæ˜¯ï¼š

<ImageTip>
  <Picture
    src={image05}
    alt={"picture components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>

é»˜è®¤çš„è¿™äº›æ–­ç‚¹æ˜¯astroé»˜è®¤é…ç½®ä¿¡æ¯ï¼Œæœ€å¤§æ”¯æŒ6K

```js
		/**
		 * @docs
		 * @name image.experimentalBreakpoints
		 * @type {number[]}
		 * @default `[640, 750, 828, 1080, 1280, 1668, 2048, 2560] | [640, 750, 828, 960, 1080, 1280, 1668, 1920, 2048, 2560, 3200, 3840, 4480, 5120, 6016]`
		 * @description
		 * The breakpoints used to generate responsive images. Requires the `experimental.responsiveImages` flag to be enabled. The full list is not normally used,
		 * but is filtered according to the source and output size. The defaults used depend on whether a local or remote image service is used. For remote services
		 * the more comprehensive list is used, because only the required sizes are generated. For local services, the list is shorter to reduce the number of images generated.
		 */
		experimentalBreakpoints?: number[];
```

# æºç è§£æ

æºç ä¹Ÿæ˜¯æ¯”è¾ƒç®€å•ï¼š
ä¸ç®¡æ˜¯\<Image>ç»„ä»¶è¿˜æ˜¯\<picture>ç»„ä»¶å†…éƒ¨å®ç°æ–¹å¼éƒ½æ˜¯åŸºäºgetImageå‡½æ•°åšå¤„ç†ï¼ŒgetImageå‡½æ•°ä¹Ÿæ˜¯å·²ç»æš´éœ²åŠŸèƒ½ï¼Œä¸è¿‡å®˜æ–¹å»ºè®®æ¨èåœ¨æœåŠ¡ç«¯çš„æ—¶å€™ä½¿ç”¨ï¼Œå®¢æˆ·ç«¯ä¸æ¨èï¼

> getImage() [relies on server-only APIs and breaks the build when used on the client](https://docs.astro.build/en/reference/modules/astro-assets/#getimage)

åœ¨Imageç»„ä»¶å’Œpicuteç»„ä»¶å†…éƒ¨æ›´æ”¹çš„å…¶å®æ¯”è¾ƒç®€å•ï¼Œæ— éå°±æ˜¯åˆ¤æ–­å½“å‰æ¨¡å¼æ˜¯å¦å¼€å¯äº†å®éªŒæ€§responsiveåŠŸèƒ½å¹¶é€šè¿‡applyResonsiveAttributeså‡½æ•°æ¥è¾“å‡ºå®éªŒæ€§åŠŸèƒ½æ‰€éœ€çš„å±æ€§æ–¹æ³•ã€‚

<ImageTip>
  <Picture
    src={image06}
    alt={"picture components"}
    formats={["avif", "webp"]}
    slot={"image"}
    class={"c-image"}
  />
  <span slot={'tip'}></span>
</ImageTip>


```ts 
import { isRemotePath } from '@astrojs/internal-helpers/path';
import { AstroError, AstroErrorData } from '../core/errors/index.js';
import type { AstroConfig } from '../types/public/config.js';
import { DEFAULT_HASH_PROPS } from './consts.js';
import {
	DEFAULT_RESOLUTIONS,
	LIMITED_RESOLUTIONS,
	getSizesAttribute,
	getWidths,
} from './layout.js';
import { type ImageService, isLocalService } from './services/service.js';
import {
	type GetImageResult,
	type ImageTransform,
	type SrcSetValue,
	type UnresolvedImageTransform,
	isImageMetadata,
} from './types.js';
import { isESMImportedImage, isRemoteImage, resolveSrc } from './utils/imageKind.js';
import { inferRemoteSize } from './utils/remoteProbe.js';

export async function getConfiguredImageService(): Promise<ImageService> {
	if (!globalThis?.astroAsset?.imageService) {
		const { default: service }: { default: ImageService } = await import(
			// @ts-expect-error
			'virtual:image-service'
		).catch((e) => {
			const error = new AstroError(AstroErrorData.InvalidImageService);
			error.cause = e;
			throw error;
		});

		if (!globalThis.astroAsset) globalThis.astroAsset = {};
		globalThis.astroAsset.imageService = service;
		return service;
	}

	return globalThis.astroAsset.imageService;
}

type ImageConfig = AstroConfig['image'] & {
	experimentalResponsiveImages: boolean;
};

export async function getImage(
	options: UnresolvedImageTransform,
	imageConfig: ImageConfig,
): Promise<GetImageResult> {

  // è¿™é‡Œå‚æ•°ä½œä¸ºå¦‚æœä¸åˆæ³•å°±return   ç®€åŒ–
  if (xxx) {
  return ///
  }

  // 2.æ‰§è¡ŒæœåŠ¡å™¨è§£æå›¾ç‰‡åœ°å€
	const service = await getConfiguredImageService();

	// If the user inlined an import, something fairly common especially in MDX, or passed a function that returns an Image, await it for them
	const resolvedOptions: ImageTransform = {
		...options,
		src: await resolveSrc(options.src),
	};

	let originalWidth: number | undefined;
	let originalHeight: number | undefined;
	let originalFormat: string | undefined;

	// Infer size for remote images if inferSize is true
	if (
		options.inferSize &&
		isRemoteImage(resolvedOptions.src) &&
		isRemotePath(resolvedOptions.src)
	) {
		const result = await inferRemoteSize(resolvedOptions.src); // Directly probe the image URL
		resolvedOptions.width ??= result.width;
		resolvedOptions.height ??= result.height;
		originalWidth = result.width;
		originalHeight = result.height;
		originalFormat = result.format;
		delete resolvedOptions.inferSize; // Delete so it doesn't end up in the attributes
	}

	const originalFilePath = isESMImportedImage(resolvedOptions.src)
		? resolvedOptions.src.fsPath
		: undefined; // Only set for ESM imports, where we do have a file path

	// Clone the `src` object if it's an ESM import so that we don't refer to any properties of the original object
	// Causing our generate step to think the image is used outside of the image optimization pipeline
	const clonedSrc = isESMImportedImage(resolvedOptions.src)
		? // @ts-expect-error - clone is a private, hidden prop
			(resolvedOptions.src.clone ?? resolvedOptions.src)
		: resolvedOptions.src;

	if (isESMImportedImage(clonedSrc)) {
		originalWidth = clonedSrc.width;
		originalHeight = clonedSrc.height;
		originalFormat = clonedSrc.format;
	}

	if (originalWidth && originalHeight) {
		// Calculate any missing dimensions from the aspect ratio, if available
		const aspectRatio = originalWidth / originalHeight;
		if (resolvedOptions.height && !resolvedOptions.width) {
			resolvedOptions.width = Math.round(resolvedOptions.height * aspectRatio);
		} else if (resolvedOptions.width && !resolvedOptions.height) {
			resolvedOptions.height = Math.round(resolvedOptions.width / aspectRatio);
		} else if (!resolvedOptions.width && !resolvedOptions.height) {
			resolvedOptions.width = originalWidth;
			resolvedOptions.height = originalHeight;
		}
	}
	resolvedOptions.src = clonedSrc;

	const layout = options.layout ?? imageConfig.experimentalLayout;

	if (imageConfig.experimentalResponsiveImages && layout) {
		resolvedOptions.widths ||= getWidths({
			width: resolvedOptions.width,
			layout,
			originalWidth,
			breakpoints: imageConfig.experimentalBreakpoints?.length
				? imageConfig.experimentalBreakpoints
				: isLocalService(service)
					? LIMITED_RESOLUTIONS
					: DEFAULT_RESOLUTIONS,
		});
		resolvedOptions.sizes ||= getSizesAttribute({ width: resolvedOptions.width, layout });

		if (resolvedOptions.priority) {
			resolvedOptions.loading ??= 'eager';
			resolvedOptions.decoding ??= 'sync';
			resolvedOptions.fetchpriority ??= 'high';
		} else {
			resolvedOptions.loading ??= 'lazy';
			resolvedOptions.decoding ??= 'async';
			resolvedOptions.fetchpriority ??= 'auto';
		}
		delete resolvedOptions.priority;
		delete resolvedOptions.densities;
	}

	const validatedOptions = service.validateOptions
		? await service.validateOptions(resolvedOptions, imageConfig)
		: resolvedOptions;

	// Get all the options for the different srcSets
	const srcSetTransforms = service.getSrcSet
		? await service.getSrcSet(validatedOptions, imageConfig)
		: [];

	let imageURL = await service.getURL(validatedOptions, imageConfig);

	const matchesOriginal = (transform: ImageTransform) =>
		transform.width === originalWidth &&
		transform.height === originalHeight &&
		transform.format === originalFormat;

	let srcSets: SrcSetValue[] = await Promise.all(
		srcSetTransforms.map(async (srcSet) => {
			return {
				transform: srcSet.transform,
				url: matchesOriginal(srcSet.transform)
					? imageURL
					: await service.getURL(srcSet.transform, imageConfig),
				descriptor: srcSet.descriptor,
				attributes: srcSet.attributes,
			};
		}),
	);

	if (
		isLocalService(service) &&
		globalThis.astroAsset.addStaticImage &&
		!(isRemoteImage(validatedOptions.src) && imageURL === validatedOptions.src)
	) {
		const propsToHash = service.propertiesToHash ?? DEFAULT_HASH_PROPS;
		imageURL = globalThis.astroAsset.addStaticImage(
			validatedOptions,
			propsToHash,
			originalFilePath,
		);
		srcSets = srcSetTransforms.map((srcSet) => {
			return {
				transform: srcSet.transform,
				url: matchesOriginal(srcSet.transform)
					? imageURL
					: globalThis.astroAsset.addStaticImage!(srcSet.transform, propsToHash, originalFilePath),
				descriptor: srcSet.descriptor,
				attributes: srcSet.attributes,
			};
		});
	}

	return {
		rawOptions: resolvedOptions,
		options: validatedOptions,
		src: imageURL,
		srcSet: {
			values: srcSets,
			attribute: srcSets.map((srcSet) => `${srcSet.url} ${srcSet.descriptor}`).join(', '),
		},
		attributes:
			service.getHTMLAttributes !== undefined
				? await service.getHTMLAttributes(validatedOptions, imageConfig)
				: {},
	};
}

```

é¦–å…ˆï¼Œè¯¥å‡½æ•°ä¼šæ‰§è¡Œ getConfiguredImageService å‡½æ•°ï¼Œä»¥åˆ¤æ–­ç”¨æˆ·æ˜¯å¦é…ç½®äº†å›¾åƒæœåŠ¡ã€‚å¦‚æœæ²¡æœ‰é…ç½®ï¼Œå®ƒä¼šå°è¯•åŠ¨æ€å¯¼å…¥ä¸€ä¸ªé»˜è®¤æœåŠ¡ï¼ŒAstro é»˜è®¤ä½¿ç”¨çš„å›¾åƒæœåŠ¡æ˜¯ sharpã€‚

å¦‚æœå¯ç”¨äº†å®éªŒæ€§åŠŸèƒ½ï¼Œç³»ç»Ÿå°†é€šè¿‡å›¾åƒæœåŠ¡è®¡ç®—ä¸åŒåˆ†è¾¨ç‡å’Œå°ºå¯¸çš„ srcsetï¼Œç„¶åè¿›è¡Œæ ¡éªŒï¼Œæœ€ç»ˆè¾“å‡º URL å’Œå±æ€§ã€‚æ€»ä½“æ¥è¯´ï¼Œä»£ç ç»“æ„ç®€å•æ˜äº†ã€‚

# æ€»ç»“

è™½ç„¶æ—©æœŸçš„ Astro å·²ç»å…·å¤‡äº†ä¸€å®šçš„å¤„ç†é€»è¾‘ï¼Œä½†æ•ˆæœå¹¶ä¸ç†æƒ³ï¼Œæ¯ä¸ªå“åº”å¼å±æ€§éƒ½éœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼Œååˆ†ç¹çã€‚ç°åœ¨ï¼Œé€šè¿‡ç®€å•çš„é…ç½®ä¿¡æ¯å³å¯å®ç°å…¨é¢ä¸”å‡ºè‰²çš„å“åº”å¼å›¾åƒå¤„ç†ã€‚

æ­¤å¤–ï¼Œä½œè€…æåˆ°æœªæ¥å°†è€ƒè™‘å®Œå–„å›¾åƒå ä½ç¬¦åŠŸèƒ½ï¼Œè®©äººéå¸¸æœŸå¾…ï¼ğŸ‘ğŸ‘

# å‚è€ƒ

+ github discussionsï¼šhttps://github.com/withastro/roadmap/discussions/1031

+ github issues:ï¼šhttps://github.com/withastro/roadmap/issues/1042

+ RFCï¼šhttps://github.com/withastro/roadmap/blob/responsive-images/proposals/0053-responsive-images.md

+ astro.docsï¼š https://docs.astro.build/zh-cn/reference/modules/astro-assets/#getimag